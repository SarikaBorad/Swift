import UIKit
import MBProgressHUD

// - - - - - - - - - - - - -
// MARK:- 📍 Extension - Date
// - - - - - - - - - - - - -

extension Date {
    
    var startOfDay: Date {
        return Calendar.current.startOfDay(for: self)
    }
    
    var endOfDay: Date? {
        var components = DateComponents()
        components.day = 1
        components.second = -1
        return Calendar.current.date(byAdding: components, to: startOfDay)
    }
    
    
    
    func GetWeekRange() -> (Date,Date) {
        let cal = Calendar.current
        
        var comps = cal.dateComponents([.weekOfYear, .yearForWeekOfYear], from: self)
        comps.weekday = 2 // Monday
        let mondayInWeek = cal.date(from: comps)!
        
        return (mondayInWeek,mondayInWeek.GetDateFrom(day: 6,datecomponent: .day))
    }
    
    func GetDateFrom(day : Int , datecomponent : Calendar.Component) -> Date {
        
         let newdate = NSCalendar.current.date(byAdding: datecomponent, value: day, to: self)
        
        return newdate!
    }
    
    func getComponent(index : Int) -> String {
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "EEEE d MMMM yyyy Q"
        let datestring = dateFormatter.string(from: self)
        let dateary = datestring.components(separatedBy: " ")
        return dateary[index]
    }
    
    
    func startOfMonth() -> Date {
        return Calendar.current.date(from: Calendar.current.dateComponents([.year, .month], from: Calendar.current.startOfDay(for: self)))!
    }
    
    func endOfMonth() -> Date {
        return Calendar.current.date(byAdding: DateComponents(month: 1, day: -1), to: self.startOfMonth())!
    }
    
    func startOfYear() -> Date {
        return Calendar.current.date(from: Calendar.current.dateComponents([.year], from: Calendar.current.startOfDay(for: self)))!
    }
    
    func endOfYear() -> Date {
        return Calendar.current.date(byAdding: DateComponents(year: 1, day: -1), to: self.startOfYear())!
    }
    
    
    func combineDateWithTime(time: Date) -> Date {
        let calendar = Calendar.current as NSCalendar
        
        let dateComponents = calendar.components([.year, .month, .day], from: self)
        let timeComponents = calendar.components([.hour, .minute, .second], from: time as Date)
        
        var mergedComponments = DateComponents()
        
        mergedComponments.year = dateComponents.year!
        mergedComponments.month = dateComponents.month!
        mergedComponments.day = dateComponents.day!
        mergedComponments.hour = timeComponents.hour!
        mergedComponments.minute = timeComponents.minute!
        mergedComponments.second = timeComponents.second!
        
        return calendar.date(from: mergedComponments)!
    }
    
    var Timestamp: String {
        
        let timesp = self.timeIntervalSince1970
        
        let strNs = NSString(format: "%.f", timesp)
        
        return "\(strNs)"
    }
    
    func dateToString(format:String)-> String {
        
        
        let dateFormatter = DateFormatter()
        dateFormatter.timeZone = TimeZone.current
        dateFormatter.dateFormat = format
        let dateString = dateFormatter.string(from: self)
        
        return dateString
    }
    
    func yearsFrom(_ date:Date) -> Int{
        return (Calendar.current as NSCalendar).components(.year, from: date, to: self, options: []).year!
    }
    func monthsFrom(_ date:Date) -> Int{
        return (Calendar.current as NSCalendar).components(.month, from: date, to: self, options: []).month!
    }
    func weeksFrom(_ date:Date) -> Int{
        return (Calendar.current as NSCalendar).components(.weekOfYear, from: date, to: self, options: []).weekOfYear!
    }
    func daysFrom(_ date:Date) -> Int{
        return (Calendar.current as NSCalendar).components(.day, from: date, to: self, options: []).day!
    }
    func hoursFrom(_ date:Date) -> Int{
        return (Calendar.current as NSCalendar).components(.hour, from: date, to: self, options: []).hour!
    }
    func minutesFrom(_ date:Date) -> Int{
        return (Calendar.current as NSCalendar).components(.minute, from: date, to: self, options: []).minute!
    }
    func secondsFrom(_ date:Date) -> Int{
        return (Calendar.current as NSCalendar).components(.second, from: date, to: self, options: []).second!
    }
    func offsetFrom(_ date:Date) -> String {
        if yearsFrom(date)   > 0 { return "\(yearsFrom(date))year"   }
        if monthsFrom(date)  > 0 { return "\(monthsFrom(date))month"  }
        if weeksFrom(date)   > 0 { return "\(weeksFrom(date))week"   }
        if daysFrom(date)    > 0 { return "\(daysFrom(date))day"    }
        if hoursFrom(date)   > 0 { return "\(hoursFrom(date))hour"   }
        if minutesFrom(date) > 0 { return "\(minutesFrom(date))min" }
        if secondsFrom(date) > 0 { return "\(secondsFrom(date))second" }
      
        
        return ""
    }
    
    
    func off_Nub_unit_setFrom(_ date:Date) -> (Int,String) {
        if yearsFrom(date)   > 0 { return (yearsFrom(date), "year")   }
        if monthsFrom(date)  > 0 { return (monthsFrom(date), "month")  }
        if weeksFrom(date)   > 0 { return (weeksFrom(date), "week")   }
        if daysFrom(date)    > 0 { return (daysFrom(date), "day")    }
        if hoursFrom(date)   > 0 { return (hoursFrom(date), "hour")   }
        if minutesFrom(date) > 0 { return (minutesFrom(date), "min") }
        if secondsFrom(date) > 0 { return (secondsFrom(date), "second") }
        
        
        return (0,"")
    }
}

// MARK:- Convert Ary to String

func convertAryToString(Ary : [String]) -> String {
    
    let stringRepresentation = Ary.joined(separator: ",")
    return stringRepresentation
}

// MARK:- Convert Ary to Json

func aryToJson(ary:Any) -> String {
    
    var jsonStr = ""
    
    do {
        
        let requestData2 = try JSONSerialization.data(withJSONObject: ary, options: .prettyPrinted)        
        jsonStr = NSString(data: requestData2, encoding: String.Encoding.utf8.rawValue)! as String
        
    }
    catch{
        
        print("catch")
    }

    return jsonStr
}


extension Double {
    
    // Rounds the double to decimal places value
    
    func roundTo(places:Int) -> Double {
        let divisor = pow(10.0, Double(places))
        return (self * divisor).rounded() / divisor
    }
}

//MARK:- convert Date From timestring

func convertDateFromTime(timestamp : String) -> Date {
    
    let timestamp = timestamp
    var interval:Double = 0
    
    let parts = timestamp.components(separatedBy: ":")
    for (index, part) in parts.reversed().enumerated() {
        interval += (Double(part) ?? 0) * pow(Double(60), Double(index))
    }
    
    let date = Date(timeIntervalSince1970: interval)
    
    return date
    
}



extension UITextField {
    
    func setPlaceHolderWhite() {
        
        self.attributedPlaceholder = NSAttributedString(string: self.placeholder!,
                                                        attributes:[NSAttributedString.Key.foregroundColor: UIColor.white])
    }
    
    func setPlaceHolderWithColor(_ color:UIColor) {
        
        self.attributedPlaceholder = NSAttributedString(string: self.placeholder!,
                                                        attributes:[NSAttributedString.Key.foregroundColor: color])
    }
    
    func copyT1T2(T2 : UITextField) {
        
        self.frame = T2.frame
        self.placeholder = T2.placeholder
        self.layer.cornerRadius = T2.layer.cornerRadius
        self.font = T2.font
        self.layer.borderColor = T2.layer.borderColor
        self.layer.borderWidth = T2.layer.borderWidth
        self.textAlignment = T2.textAlignment
        self.textColor = T2.textColor
        self.delegate = T2.delegate
        self.keyboardType = T2.keyboardType       
        
    }
    
}

extension UITextField : UITextFieldDelegate {
    
    
    func setUnderLineDark(){
    
        let borderUser = CALayer()
        let widthUser = CGFloat(1.0)
        borderUser.borderColor = UIColor.lightGray.cgColor
        borderUser.frame = CGRect(x: 0, y: self.frame.size.height - widthUser, width:  self.frame.size.width, height: self.frame.size.height)
        
        borderUser.borderWidth = widthUser
        self.layer.addSublayer(borderUser)
        
        let lView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 40))
        self.leftView = lView
        self.leftViewMode = UITextField.ViewMode.always;
        
        self.autocorrectionType = UITextAutocorrectionType.no
    }
    
    func setUnderLineBack(){
        
        let borderUser = CALayer()
        let widthUser = CGFloat(0.5)
        borderUser.borderColor = UIColor.black.cgColor
        borderUser.frame = CGRect(x: 0, y: self.frame.size.height - widthUser, width:  self.frame.size.width, height: widthUser)
        
        borderUser.borderWidth = widthUser
        self.layer.addSublayer(borderUser)
        
//        let lView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 40))
//        self.leftView = lView
//        self.leftViewMode = UITextFieldViewMode.always;
    }
    
    func setCorner(_ color:UIColor){
        
        self.layer.borderColor = color.cgColor
        self.layer.borderWidth = 1.0
        self.layer.cornerRadius = 20.0
        
        let lView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 40))
        self.leftView = lView
        self.leftViewMode = UITextField.ViewMode.always;
    }
    
    func setColorBox(_ color:UIColor){
        
        self.layer.borderColor = color.cgColor
        self.layer.borderWidth = 1.0
        
        let lView = UIView(frame: CGRect(x: 0, y: 0, width: 10, height: 40))
        self.leftView = lView
        self.leftViewMode = UITextField.ViewMode.always;
    }
    func setColorWithCorner(_ color:UIColor){
        
        self.layer.borderColor = color.cgColor
        self.layer.borderWidth = 1.0
        
        self.layer.cornerRadius = self.vHeight*0.5
    }
    
    
    func LeftIcon(tf_L_Icon setIName:String){
        
        
        let borderUser = CALayer()
        let widthUser = CGFloat(0.5)
        borderUser.borderColor = Appcolor.current_text_color.cgColor
        borderUser.frame = CGRect(x: 0, y: self.frame.size.height - widthUser, width:  self.frame.size.width, height: self.frame.size.height)
        
        borderUser.borderWidth = widthUser
        self.layer.addSublayer(borderUser)
        
        
        let lView = UIView(frame: CGRect(x: 0, y: 0, width: 40, height: 40))
        let setIV = UIImageView(image: UIImage(named: setIName))
        setIV.center = lView.center
        setIV.frame.origin.x = 0.0
        lView.addSubview(setIV)
        self.leftView = lView
        
        self.leftViewMode = UITextField.ViewMode.always;
    }
    func RightIcon(tf_R_Icon rIM:UIImage){
        
        let setIVr = UIImageView()
        setIVr.frame = CGRect(x: self.XW - 30, y: self.YPOINT, width: 18, height: 10)
        setIVr.center.y = self.center.y
        setIVr.image = rIM
        setIVr.isUserInteractionEnabled = true
        self.superview?.addSubview(setIVr)

    }
}

  // - - - - - - - - - - - - - - - - - - - -
 // MARK:- 📍 Extension - NSMutableData. 📌
// - - - - - - - - - - - - - - - - - - - -

extension NSMutableData {
    
    func appendString(_ string: String) {
        let data = string.data(using: String.Encoding.utf8, allowLossyConversion: true)
        append(data!)
    }
    
}

 // - - - - - - - - - - - - - - - - - - - -
 // MARK:- 📍 to get Random String 📌
// - - - - - - - - - - - - - - - - - - - -


func randomString(length: Int) -> String {
    
    let letters : NSString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    let len = UInt32(letters.length)
    
    var randomString = ""
    
    for _ in 0 ..< length {
        let rand = arc4random_uniform(len)
        var nextChar = letters.character(at: Int(rand))
        randomString += NSString(characters: &nextChar, length: 1) as String
    }
    
    return randomString
}


